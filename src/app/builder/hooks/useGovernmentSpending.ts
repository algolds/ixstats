/**
 * Government Spending State Management Hook.
 *
 * Centralizes all spending-related state and logic, integrating:
 * - Budget allocations and utilization tracking
 * - Policy selection and presets
 * - Atomic component integration
 * - Government builder synchronization
 * - Spending visualization data
 *
 * Refactored from GovernmentSpendingSectionEnhanced.tsx for modularity and reusability.
 */

import { useState, useEffect, useMemo, useRef } from 'react';
import { ComponentType } from '~/components/government/atoms/AtomicGovernmentComponents';
import { atomicIntegrationService } from '../services/AtomicIntegrationService';
import { generateGovernmentBuilderFromAtomicComponents } from '../utils/atomicGovernmentIntegration';
import { validateGovernmentSpendingSource } from '../utils/governmentValidation';
import type { EconomicInputs } from '../lib/economy-data-service';
import type { GovernmentBuilderState } from '~/types/government';
import { SPENDING_POLICIES } from '../data/government-spending-policies';
import { api } from '~/trpc/react';

const ALL_POLICY_IDS = SPENDING_POLICIES.map(policy => policy.id);

/**
 * Props interface for useGovernmentSpending hook.
 */
export interface UseGovernmentSpendingProps {
  /** Economic inputs containing spending data */
  inputs: EconomicInputs;
  /** Callback when inputs change */
  onInputsChange: (inputs: EconomicInputs) => void;
  /** Selected atomic government components */
  selectedAtomicComponents?: ComponentType[];
  /** Traditional government builder state */
  governmentBuilderData?: GovernmentBuilderState | null;
  /** Country ID for tracking (optional) */
  countryId?: string;
}

/**
 * Government spending state management hook.
 *
 * Manages comprehensive government spending workflow:
 * - Budget tracking (total, allocated, revenue, utilization)
 * - Policy selection with atomic component integration
 * - Policy presets (welfare state, free market, etc.)
 * - Automatic government builder generation
 * - Spending category visualization data
 * - Validation and error states
 * - Integration service synchronization
 *
 * Automatically detects and applies policies based on selected atomic components,
 * ensuring consistency between component-based and traditional builder approaches.
 *
 * @hook
 * @param {UseGovernmentSpendingProps} props - Spending configuration
 * @param {EconomicInputs} props.inputs - Economic inputs with spending data
 * @param {Function} props.onInputsChange - Callback for input updates
 * @param {ComponentType[]} props.selectedAtomicComponents - Atomic components
 * @param {GovernmentBuilderState|null} props.governmentBuilderData - Builder state
 * @param {string} props.countryId - Country identifier (optional)
 * @returns {Object} Spending state and methods
 *
 * @example
 * ```tsx
 * function GovernmentSpendingSection() {
 *   const [economicInputs, setEconomicInputs] = useState<EconomicInputs>(defaults);
 *   const {
 *     selectedPolicies,
 *     togglePolicy,
 *     totalBudget,
 *     totalAllocated,
 *     budgetUtilization,
 *     isValidBudget,
 *     spendingData,
 *     validation
 *   } = useGovernmentSpending({
 *     inputs: economicInputs,
 *     onInputsChange: setEconomicInputs,
 *     selectedAtomicComponents: [ComponentType.WELFARE_STATE],
 *     governmentBuilderData: null
 *   });
 *
 *   return (
 *     <div>
 *       <h3>Budget: ${totalBudget.toLocaleString()}</h3>
 *       <p>Utilization: {budgetUtilization.toFixed(1)}%</p>
 *       {!isValidBudget && (
 *         <p className="text-red-500">Budget must be within 5% of 100%</p>
 *       )}
 *       <SpendingChart data={spendingData} />
 *       <PolicySelector
 *         selected={selectedPolicies}
 *         onToggle={togglePolicy}
 *       />
 *     </div>
 *   );
 * }
 * ```
 *
 * @example
 * ```tsx
 * // Policy preset application
 * function PolicyPresetSelector() {
 *   const { applyPolicyPreset } = useGovernmentSpending({
 *     inputs,
 *     onInputsChange: setInputs
 *   });
 *
 *   const presets = [
 *     { name: 'Welfare State', policies: ['universalBasicServices', 'progressiveTaxation'] },
 *     { name: 'Free Market', policies: ['publicPrivatePartnerships', 'performanceBasedBudgeting'] }
 *   ];
 *
 *   return (
 *     <div>
 *       {presets.map(preset => (
 *         <button
 *           key={preset.name}
 *           onClick={() => applyPolicyPreset(preset.policies)}
 *         >
 *           {preset.name}
 *         </button>
 *       ))}
 *     </div>
 *   );
 * }
 * ```
 *
 * @example
 * ```tsx
 * // Atomic component integration
 * function AutomatedPolicyDetection() {
 *   const {
 *     selectedPolicies,
 *     handleAtomicComponentUpdate,
 *     autoGeneratedBuilder
 *   } = useGovernmentSpending({
 *     inputs,
 *     onInputsChange: setInputs,
 *     selectedAtomicComponents: [
 *       ComponentType.WELFARE_STATE,
 *       ComponentType.ENVIRONMENTAL_PROTECTION,
 *       ComponentType.DIGITAL_INFRASTRUCTURE
 *     ]
 *   });
 *
 *   useEffect(() => {
 *     handleAtomicComponentUpdate();
 *     // Automatically selects policies based on atomic components:
 *     // - universalBasicServices (from WELFARE_STATE)
 *     // - greenInvestmentPriority (from ENVIRONMENTAL_PROTECTION)
 *     // - digitalGovernmentInitiative (from DIGITAL_INFRASTRUCTURE)
 *   }, []);
 *
 *   return (
 *     <div>
 *       <h4>Auto-Selected Policies:</h4>
 *       {Array.from(selectedPolicies).map(policy => (
 *         <span key={policy}>{policy}</span>
 *       ))}
 *       {autoGeneratedBuilder && <p>Builder generated from components</p>}
 *     </div>
 *   );
 * }
 * ```
 */
export function useGovernmentSpending({
  inputs,
  onInputsChange,
  selectedAtomicComponents = [],
  governmentBuilderData = null,
  countryId
}: UseGovernmentSpendingProps) {
  // State
  const [selectedPolicies, setSelectedPolicies] = useState<Set<string>>(new Set());
  const [policyOverrides, setPolicyOverrides] = useState<Map<string, boolean>>(new Map());
  const [autoGeneratedBuilder, setAutoGeneratedBuilder] = useState<GovernmentBuilderState | null>(null);
  const [integrationState, setIntegrationState] = useState(atomicIntegrationService.getState());

  // tRPC mutations for database operations
  const savePolicySelectionsMutation = api.policies.savePolicySelections.useMutation();
  const calculatePolicyEffectsQuery = api.policies.calculatePolicyEffects.useQuery(
    { countryId: countryId || '' },
    { enabled: !!countryId }
  );

  // Validation
  const validation = useMemo(() =>
    validateGovernmentSpendingSource(inputs, governmentBuilderData),
    [inputs, governmentBuilderData]
  );

  // Budget calculations
  const totalBudget = governmentBuilderData?.structure?.totalBudget || inputs.governmentSpending.totalSpending || 0;
  const totalAllocated = useMemo(() =>
    governmentBuilderData?.budgetAllocations?.reduce((sum, alloc) => sum + (alloc.allocatedAmount || 0), 0) || 0,
    [governmentBuilderData?.budgetAllocations]
  );
  const totalRevenue = useMemo(() =>
    governmentBuilderData?.revenueSources?.reduce((sum, rev) => sum + (rev.revenueAmount || 0), 0) || 0,
    [governmentBuilderData?.revenueSources]
  );

  const budgetUtilization = totalBudget > 0 ? (totalAllocated / totalBudget) * 100 : 0;
  const isValidBudget = Math.abs(budgetUtilization - 100) <= 5; // 5% tolerance
  const isSurplus = totalRevenue >= totalAllocated;

  // Spending data for visualizations
  const spendingData = useMemo(() => {
    if (governmentBuilderData?.departments && governmentBuilderData.budgetAllocations) {
      // Use government builder data
      return governmentBuilderData.departments.map((dept, index) => {
        const allocation = governmentBuilderData.budgetAllocations.find(
          a => a.departmentId === index.toString()
        );
        return {
          id: dept.name,
          name: dept.name,
          value: allocation?.allocatedPercent || 0,
          color: dept.color || '#3b82f6'
        };
      });
    } else if (inputs.governmentSpending.spendingCategories) {
      // Fallback to spending categories from inputs
      return inputs.governmentSpending.spendingCategories.map(cat => ({
        id: cat.category,
        name: cat.category,
        value: cat.percent || 0,
        color: cat.color || '#3b82f6'
      }));
    }

    return [];
  }, [governmentBuilderData, inputs.governmentSpending.spendingCategories]);

  // Track last sent values to prevent redundant updates
  const lastSentComponentsRef = useRef<ComponentType[]>([]);
  const lastSentGovernmentBuilderRef = useRef<any>(null);
  const lastSentInputsRef = useRef<EconomicInputs | null>(null);

  // Subscribe to atomic integration service once
  useEffect(() => {
    const unsubscribe = atomicIntegrationService.subscribe(setIntegrationState);
    return unsubscribe;
  }, []);

  // Consolidated effect for updating service with guards
  useEffect(() => {
    // Update components if changed
    if (selectedAtomicComponents.length > 0 && 
        JSON.stringify(selectedAtomicComponents) !== JSON.stringify(lastSentComponentsRef.current)) {
      lastSentComponentsRef.current = [...selectedAtomicComponents];
      atomicIntegrationService.updateComponents(selectedAtomicComponents);
    }

    // Update government builder if changed
    if (governmentBuilderData && 
        JSON.stringify(governmentBuilderData) !== JSON.stringify(lastSentGovernmentBuilderRef.current)) {
      lastSentGovernmentBuilderRef.current = governmentBuilderData;
      atomicIntegrationService.updateGovernmentBuilder(governmentBuilderData);
    }

    // Update inputs if changed
    if (inputs && 
        JSON.stringify(inputs) !== JSON.stringify(lastSentInputsRef.current)) {
      lastSentInputsRef.current = inputs;
      atomicIntegrationService.updateEconomicInputs(inputs);
    }
  }, [selectedAtomicComponents, governmentBuilderData, inputs]);

  // Auto-generate government builder from atomic components
  useEffect(() => {
    if (selectedAtomicComponents.length > 0 && !governmentBuilderData && validation.hasGovernmentBuilder === false) {
      const generated = generateGovernmentBuilderFromAtomicComponents(
        selectedAtomicComponents,
        inputs.governmentSpending.totalSpending,
        inputs
      );
      setAutoGeneratedBuilder(generated);
    }
  }, [selectedAtomicComponents, governmentBuilderData, validation.hasGovernmentBuilder, inputs]);

  // Track previous values to prevent unnecessary updates
  const prevSelectedComponentsRef = useRef<ComponentType[]>([]);
  const prevGovernmentSpendingRef = useRef<any>(null);

  // Initialize selected policies from atomic components and current state
  useEffect(() => {
    // Check if dependencies have actually changed
    const componentsChanged = JSON.stringify(selectedAtomicComponents) !== JSON.stringify(prevSelectedComponentsRef.current);
    const spendingChanged = JSON.stringify(inputs.governmentSpending) !== JSON.stringify(prevGovernmentSpendingRef.current);

    if (!componentsChanged && !spendingChanged) {
      return; // No changes, skip update
    }

    const policies = new Set<string>();

    // Auto-select policies based on atomic components
    if (
      selectedAtomicComponents.includes(ComponentType.PERFORMANCE_LEGITIMACY) &&
      (inputs.governmentSpending as any).performanceBasedBudgeting !== false
    ) {
      policies.add('performanceBasedBudgeting');
    }
    if (
      (selectedAtomicComponents.includes(ComponentType.WELFARE_STATE) ||
        selectedAtomicComponents.includes(ComponentType.UNIVERSAL_HEALTHCARE)) &&
      (inputs.governmentSpending as any).universalBasicServices !== false
    ) {
      policies.add('universalBasicServices');
    }
    if (
      selectedAtomicComponents.includes(ComponentType.ENVIRONMENTAL_PROTECTION) &&
      (inputs.governmentSpending as any).greenInvestmentPriority !== false
    ) {
      policies.add('greenInvestmentPriority');
    }
    if (
      (selectedAtomicComponents.includes(ComponentType.DIGITAL_INFRASTRUCTURE) ||
        selectedAtomicComponents.includes(ComponentType.SMART_CITIES)) &&
      (inputs.governmentSpending as any).digitalGovernmentInitiative !== false
    ) {
      policies.add('digitalGovernmentInitiative');
    }
    if (
      (selectedAtomicComponents.includes(ComponentType.TECHNOCRATIC_PROCESS) ||
        selectedAtomicComponents.includes(ComponentType.PROFESSIONAL_BUREAUCRACY)) &&
      (inputs.governmentSpending as any).zeroBasedBudgeting !== false
    ) {
      policies.add('zeroBasedBudgeting');
    }
    if (
      (selectedAtomicComponents.includes(ComponentType.FREE_MARKET_SYSTEM) ||
        selectedAtomicComponents.includes(ComponentType.ECONOMIC_INCENTIVES)) &&
      (inputs.governmentSpending as any).publicPrivatePartnerships !== false
    ) {
      policies.add('publicPrivatePartnerships');
    }

    // Include all currently selected policies from inputs
    ALL_POLICY_IDS.forEach(field => {
      if ((inputs.governmentSpending as any)[field]) {
        policies.add(field);
      }
    });

    policyOverrides.forEach((overrideValue, policyId) => {
      if (overrideValue) {
        policies.add(policyId);
      } else {
        policies.delete(policyId);
      }
    });

    setSelectedPolicies(policies);

    // Update refs with current values
    prevSelectedComponentsRef.current = [...selectedAtomicComponents];
    prevGovernmentSpendingRef.current = { ...inputs.governmentSpending };
  }, [selectedAtomicComponents, inputs.governmentSpending, policyOverrides]);

  // Toggle policy selection
  const togglePolicy = (policyId: string) => {
    const shouldSelect = !selectedPolicies.has(policyId);

    setPolicyOverrides(prev => {
      const next = new Map(prev);
      next.set(policyId, shouldSelect);
      return next;
    });

    const newPolicies = new Set(selectedPolicies);
    if (shouldSelect) {
      newPolicies.add(policyId);
    } else {
      newPolicies.delete(policyId);
    }
    setSelectedPolicies(newPolicies);

    const updatedSpending = { ...inputs.governmentSpending };
    (updatedSpending as any)[policyId] = shouldSelect;

    onInputsChange({
      ...inputs,
      governmentSpending: updatedSpending
    });
  };

  // Apply policy preset
  const applyPolicyPreset = (policyIds: string[]) => {
    const newPolicies = new Set(policyIds);
    setSelectedPolicies(newPolicies);

    setPolicyOverrides(() => {
      const overrides = new Map<string, boolean>();
      ALL_POLICY_IDS.forEach((policyId) => {
        overrides.set(policyId, policyIds.includes(policyId));
      });
      return overrides;
    });

    // Update inputs with new policy selections
    const updatedSpending = { ...inputs.governmentSpending };
    Object.keys(updatedSpending).forEach(key => {
      if (typeof updatedSpending[key as keyof typeof updatedSpending] === 'boolean') {
        (updatedSpending as any)[key] = policyIds.includes(key);
      }
    });

    onInputsChange({
      ...inputs,
      governmentSpending: updatedSpending
    });
  };

  // Handle atomic component update
  const handleAtomicComponentUpdate = () => {
    if (selectedAtomicComponents.length > 0) {
      const generated = generateGovernmentBuilderFromAtomicComponents(
        selectedAtomicComponents,
        inputs.governmentSpending.totalSpending,
        inputs
      );

      // Update economic inputs with generated government data
      const updatedInputs = {
        ...inputs,
        governmentSpending: {
          ...inputs.governmentSpending,
          totalSpending: generated.structure.totalBudget,
          spendingGDPPercent: inputs.coreIndicators.nominalGDP > 0
            ? (generated.structure.totalBudget / inputs.coreIndicators.nominalGDP) * 100
            : 35,
          spendingCategories: generated.departments.map((dept, index) => {
            const allocation = generated.budgetAllocations.find(a => a.departmentId === index.toString());
            return {
              category: dept.name,
              amount: allocation?.allocatedAmount || 0,
              percent: allocation?.allocatedPercent || 0,
              icon: dept.icon,
              color: dept.color,
              description: dept.description
            };
          })
        }
      };

      onInputsChange(updatedInputs);
    }
  };

  // Save policy selections to database
  const savePolicySelections = async () => {
    if (!countryId || selectedPolicies.size === 0) return;

    try {
        const policySelections = Array.from(selectedPolicies).map(policyId => {
          const policy = SPENDING_POLICIES.find(p => p.id === policyId);
          return {
            name: policy?.name || policyId,
            description: policy?.description || '',
            policyType: 'economic',
            category: 'spending', // Default category for spending policies
            relatedGovernmentComponents: selectedAtomicComponents,
            gdpEffect: policy?.impact?.efficiency ? policy.impact.efficiency * 0.1 : 0, // Convert impact to percentage
            employmentEffect: policy?.impact?.efficiency ? policy.impact.efficiency * 0.05 : 0,
            inflationEffect: policy?.impact?.stability ? -policy.impact.stability * 0.02 : 0, // Stability reduces inflation
            taxRevenueEffect: policy?.impact?.efficiency ? policy.impact.efficiency * 0.08 : 0,
            implementationCost: 0, // Default implementation cost
            maintenanceCost: 0, // Default maintenance cost
          };
        });

      await savePolicySelectionsMutation.mutateAsync({
        countryId,
        policySelections,
      });
    } catch (error) {
      console.error('Failed to save policy selections:', error);
    }
  };

  return {
    // State
    selectedPolicies,
    autoGeneratedBuilder,
    integrationState,

    // Computed values
    validation,
    totalBudget,
    totalAllocated,
    totalRevenue,
    budgetUtilization,
    isValidBudget,
    isSurplus,
    spendingData,
    policyEffects: calculatePolicyEffectsQuery.data,

    // Actions
    togglePolicy,
    applyPolicyPreset,
    handleAtomicComponentUpdate,
    savePolicySelections,
    isSavingPolicies: savePolicySelectionsMutation.isPending,
  };
}
