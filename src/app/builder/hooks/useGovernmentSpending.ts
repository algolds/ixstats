// Custom hook for government spending state management
// Refactored from GovernmentSpendingSectionEnhanced.tsx
// Centralizes all spending-related state and logic

import { useState, useEffect, useMemo } from 'react';
import { ComponentType } from '~/components/government/atoms/AtomicGovernmentComponents';
import { atomicIntegrationService } from '../services/AtomicIntegrationService';
import { generateGovernmentBuilderFromAtomicComponents } from '../utils/atomicGovernmentIntegration';
import { validateGovernmentSpendingSource } from '../utils/governmentValidation';
import type { EconomicInputs } from '../lib/economy-data-service';
import type { GovernmentBuilderState } from '~/types/government';
import { SPENDING_POLICIES } from '../data/government-spending-policies';

export interface UseGovernmentSpendingProps {
  inputs: EconomicInputs;
  onInputsChange: (inputs: EconomicInputs) => void;
  selectedAtomicComponents?: ComponentType[];
  governmentBuilderData?: GovernmentBuilderState | null;
  countryId?: string;
}

export function useGovernmentSpending({
  inputs,
  onInputsChange,
  selectedAtomicComponents = [],
  governmentBuilderData = null,
  countryId
}: UseGovernmentSpendingProps) {
  // State
  const [selectedPolicies, setSelectedPolicies] = useState<Set<string>>(new Set());
  const [autoGeneratedBuilder, setAutoGeneratedBuilder] = useState<GovernmentBuilderState | null>(null);
  const [integrationState, setIntegrationState] = useState(atomicIntegrationService.getState());

  // Validation
  const validation = useMemo(() =>
    validateGovernmentSpendingSource(inputs, governmentBuilderData),
    [inputs, governmentBuilderData]
  );

  // Budget calculations
  const totalBudget = governmentBuilderData?.structure?.totalBudget || inputs.governmentSpending.totalSpending || 0;
  const totalAllocated = useMemo(() =>
    governmentBuilderData?.budgetAllocations?.reduce((sum, alloc) => sum + (alloc.allocatedAmount || 0), 0) || 0,
    [governmentBuilderData?.budgetAllocations]
  );
  const totalRevenue = useMemo(() =>
    governmentBuilderData?.revenueSources?.reduce((sum, rev) => sum + (rev.revenueAmount || 0), 0) || 0,
    [governmentBuilderData?.revenueSources]
  );

  const budgetUtilization = totalBudget > 0 ? (totalAllocated / totalBudget) * 100 : 0;
  const isValidBudget = Math.abs(budgetUtilization - 100) <= 5; // 5% tolerance
  const isSurplus = totalRevenue >= totalAllocated;

  // Spending data for visualizations
  const spendingData = useMemo(() => {
    if (governmentBuilderData?.departments && governmentBuilderData.budgetAllocations) {
      // Use government builder data
      return governmentBuilderData.departments.map((dept, index) => {
        const allocation = governmentBuilderData.budgetAllocations.find(
          a => a.departmentId === index.toString()
        );
        return {
          id: dept.name,
          name: dept.name,
          value: allocation?.allocatedPercent || 0,
          color: dept.color || '#3b82f6'
        };
      });
    } else if (inputs.governmentSpending.spendingCategories) {
      // Fallback to spending categories from inputs
      return inputs.governmentSpending.spendingCategories.map(cat => ({
        id: cat.category,
        name: cat.category,
        value: cat.percent || 0,
        color: cat.color || '#3b82f6'
      }));
    }

    return [];
  }, [governmentBuilderData, inputs.governmentSpending.spendingCategories]);

  // Subscribe to atomic integration service
  useEffect(() => {
    const unsubscribe = atomicIntegrationService.subscribe(setIntegrationState);
    return unsubscribe;
  }, []);

  // Update atomic integration service when props change
  useEffect(() => {
    if (selectedAtomicComponents.length > 0) {
      atomicIntegrationService.updateComponents(selectedAtomicComponents);
    }
  }, [selectedAtomicComponents]);

  useEffect(() => {
    if (governmentBuilderData) {
      atomicIntegrationService.updateGovernmentBuilder(governmentBuilderData);
    }
  }, [governmentBuilderData]);

  useEffect(() => {
    atomicIntegrationService.updateEconomicInputs(inputs);
  }, [inputs]);

  // Auto-generate government builder from atomic components
  useEffect(() => {
    if (selectedAtomicComponents.length > 0 && !governmentBuilderData && validation.hasGovernmentBuilder === false) {
      const generated = generateGovernmentBuilderFromAtomicComponents(
        selectedAtomicComponents,
        inputs.governmentSpending.totalSpending,
        inputs
      );
      setAutoGeneratedBuilder(generated);
    }
  }, [selectedAtomicComponents, governmentBuilderData, validation.hasGovernmentBuilder, inputs]);

  // Initialize selected policies from atomic components and current state
  useEffect(() => {
    const policies = new Set<string>();

    // Auto-select policies based on atomic components
    if (selectedAtomicComponents.includes(ComponentType.PERFORMANCE_LEGITIMACY)) {
      policies.add('performanceBasedBudgeting');
    }
    if (selectedAtomicComponents.includes(ComponentType.WELFARE_STATE) || selectedAtomicComponents.includes(ComponentType.UNIVERSAL_HEALTHCARE)) {
      policies.add('universalBasicServices');
    }
    if (selectedAtomicComponents.includes(ComponentType.ENVIRONMENTAL_PROTECTION)) {
      policies.add('greenInvestmentPriority');
    }
    if (selectedAtomicComponents.includes(ComponentType.DIGITAL_INFRASTRUCTURE) || selectedAtomicComponents.includes(ComponentType.SMART_CITIES)) {
      policies.add('digitalGovernmentInitiative');
    }
    if (selectedAtomicComponents.includes(ComponentType.TECHNOCRATIC_PROCESS) || selectedAtomicComponents.includes(ComponentType.PROFESSIONAL_BUREAUCRACY)) {
      policies.add('zeroBasedBudgeting');
    }
    if (selectedAtomicComponents.includes(ComponentType.FREE_MARKET_SYSTEM) || selectedAtomicComponents.includes(ComponentType.ECONOMIC_INCENTIVES)) {
      policies.add('publicPrivatePartnerships');
    }

    // Include all currently selected policies from inputs
    const policyFields = SPENDING_POLICIES.map(p => p.id);

    policyFields.forEach(field => {
      if ((inputs.governmentSpending as any)[field]) {
        policies.add(field);
      }
    });

    setSelectedPolicies(policies);
  }, [selectedAtomicComponents, inputs.governmentSpending]);

  // Toggle policy selection
  const togglePolicy = (policyId: string) => {
    const newPolicies = new Set(selectedPolicies);
    if (newPolicies.has(policyId)) {
      newPolicies.delete(policyId);
    } else {
      newPolicies.add(policyId);
    }
    setSelectedPolicies(newPolicies);

    // Update the policy field in the spending data
    const updatedSpending = { ...inputs.governmentSpending };
    const isSelected = newPolicies.has(policyId);
    (updatedSpending as any)[policyId] = isSelected;

    onInputsChange({
      ...inputs,
      governmentSpending: updatedSpending
    });
  };

  // Apply policy preset
  const applyPolicyPreset = (policyIds: string[]) => {
    const newPolicies = new Set(policyIds);
    setSelectedPolicies(newPolicies);

    // Update inputs with new policy selections
    const updatedSpending = { ...inputs.governmentSpending };
    Object.keys(updatedSpending).forEach(key => {
      if (typeof updatedSpending[key as keyof typeof updatedSpending] === 'boolean') {
        (updatedSpending as any)[key] = policyIds.includes(key);
      }
    });

    onInputsChange({
      ...inputs,
      governmentSpending: updatedSpending
    });
  };

  // Handle atomic component update
  const handleAtomicComponentUpdate = () => {
    if (selectedAtomicComponents.length > 0) {
      const generated = generateGovernmentBuilderFromAtomicComponents(
        selectedAtomicComponents,
        inputs.governmentSpending.totalSpending,
        inputs
      );

      // Update economic inputs with generated government data
      const updatedInputs = {
        ...inputs,
        governmentSpending: {
          ...inputs.governmentSpending,
          totalSpending: generated.structure.totalBudget,
          spendingGDPPercent: inputs.coreIndicators.nominalGDP > 0
            ? (generated.structure.totalBudget / inputs.coreIndicators.nominalGDP) * 100
            : 35,
          spendingCategories: generated.departments.map((dept, index) => {
            const allocation = generated.budgetAllocations.find(a => a.departmentId === index.toString());
            return {
              category: dept.name,
              amount: allocation?.allocatedAmount || 0,
              percent: allocation?.allocatedPercent || 0,
              icon: dept.icon,
              color: dept.color,
              description: dept.description
            };
          })
        }
      };

      onInputsChange(updatedInputs);
    }
  };

  return {
    // State
    selectedPolicies,
    autoGeneratedBuilder,
    integrationState,

    // Computed values
    validation,
    totalBudget,
    totalAllocated,
    totalRevenue,
    budgetUtilization,
    isValidBudget,
    isSurplus,
    spendingData,

    // Actions
    togglePolicy,
    applyPolicyPreset,
    handleAtomicComponentUpdate
  };
}
